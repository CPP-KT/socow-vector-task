# Vector со small-object и copy-on-write оптимизациями

В этом задании необходимо реализовать класс, аналогичный `std::vector`, но имеющий *small-object* и *copy-on-write* оптимизации.

*Small-object* предполагает, что вектор умеет хранить небольшое число элементов без динамической аллокации памяти.

*Copy-on-write* предполагает, что
копирование/присваивание больших векторов не копирует все элементы само, а откладывает копирование элементов до момента, когда к объекту применят модифицирующую операцию.

Реализуемый класс должен называться `socow_vector` и лежать в заголовочном файле `socow-vector.h`. Он должен иметь два шаблонных параметра: тип хранимых объектов и размер маленького буффера.

```cpp
template <typename T, std::size_t SMALL_SIZE>
class socow_vector;
```

Из-за наличия *small-object* и *copy-on-write* оптимизаций, некоторые операции имеют другую вычислительную сложность и/или предоставляют другую гарантию безопасности исключений:

- Конструктор копирования и оператор присваивания должны работать за `O(SMALL_SIZE)`, а не за `O(size)`.
- Если размеры и `a`, и `b` не больше `SMALL_SIZE`, `a = b` должен предоставлять сильную гарантию безопасности исключений, иначе nothrow.
- Неконстантные операции `operator[]`, `data()`, `front()`, `back()`, `begin()`, `end()` должны работать за `O(size)` и удовлетворять сильной гарантии безопасности исключений, если требуется копирование для *copy-on-write*, и за `O(1)` и nothrow иначе.
- Как и со стандартным вектором, `reserve` должен гарантировать, что после выполнения `reserve(n)` вставки в вектор не будут приводить к переаллокациям, пока размер не достигнет `n`.

Вы можете полагаться, что конструктор перемещения и оператор перемещающего присваивания для `T` не бросают исключения.
